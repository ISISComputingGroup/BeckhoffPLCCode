<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4020.12">
  <POU Name="AxDriveFB_V3" Id="{3fd91f62-b5bf-4e2f-976b-4369ae146222}" SpecialFunc="None">
    <Declaration><![CDATA[//notes
// For any continuos movements I think I need to move out of state machine architecture to allow multiple commands to be issued.

FUNCTION_BLOCK AxDriveFB_V3
VAR_INPUT

END_VAR
VAR_IN_OUT
	AxisController		:	AxisControl;
END_VAR
VAR_OUTPUT

END_VAR
VAR
	uCommand	:	McCommand;
	bTest		: 	BOOL;
	heartBeat	:	UINT;
	executeTrig	:	R_TRIG;
	doneLatch	:	SR;
	errorLatch	:	SR;
	bError		:	BOOL;
	bDone		:	BOOL;
	iParam		:	INT:=1;
	
//FBs as defined by PLC Open Standard
	//ADMIN
	MCReset					:	MC_Reset;											//1
	MCPower					:	MC_Power;											//2 - DOES NOT REQUIRE AN EXECUTE
	MCReadStatus			:	MC_ReadStatus;										//3 - Same as Axis.readstatus
	MCReadAxisError			:	MC_ReadAxisError;									//4
	MCReadParameter			:	MC_ReadParameter;									//5





MCReadBoolParameter		:	MC_ReadBoolParameter;								//6
	










MCWriteParameter		:	MC_WriteParameter;										//7
	MCWriteBoolParameter	:	MC_WriteBoolParameter;								//8
	//MCReadDigitalInput		:	MC_ReadDigitalInput;	//NOT IMPLEMENTED		//9
	//MCReadDigitalOutput			:	MC_ReadDigitalOutput;	//NOT IMPLEMENTED	//10
	//MCWriteDigitalOutput			:	MC_WriteDigitalOutput;	//NOT IMPLEMENTED	//11
	MCReadActualPosition	:	MC_ReadActualPosition;								//12
	MCReadActualVelocity	:	MC_ReadActualVelocity;								//13
	//MCReadActualTorque		:	MC_ReadActualTorque;		//NOT IMPLEMENTED	//14
	//MCReadAxisInfo			:	MC_ReadAxisInfo;			//NOT IMPLEMENTED	//15
	//MCReadMotionState		:	MC_ReadMotionState;				//NOT IMPLEMENTED	//16
	MCSetPosition			:	MC_SetPosition;										//17
	MCSetOverride			:	MC_SetOverride;										//18
	MCTouchProbe			:	MC_TouchProbe;										//19
	//MCDigitalCamSwitch		:	MC_DigitalCamSwitch;		//NOT IMPLEMENTED	//20
	MCAbortTrigger			:	MC_AbortTrigger;									//21
	MCAbortSuperposition		:	MC_AbortSuperposition;		//HaltSuperimposed?	//22
	MCCamTableSelect		:	MC_CamTableSelect;									//23
	
	//MOTION
	MCHome					:	MC_Home;											//24
	MCJog					:	MC_Jog;												//25
	MCStop					:	MC_Stop;											//26
	MCHalt					:	MC_Halt;											//27
	MCMoveAbsolute			:	MC_MoveAbsolute;									//28
	MCMoveRelative			:	MC_MoveRelative;									//29
	MCMoveAdditive			:	MC_MoveAdditive;									//30
	MCMoveSuperimposed		:	MC_MoveSuperimposed;								//31
	MCMoveVelocity			:	MC_MoveVelocity;									//32*****
	MCMoveContinuousAbsolute	:	MC_MoveContinuousAbsolute;						//33
	MCMoveContinuousRelative	:	MC_MoveContinuousRelative;						//34
	MCMoveModulo			:	MC_MoveModulo;										//35
	//MCTorqueControl			:	MC_TorqueControl;		//NOT IMPLEMENTED		//36
	//MCPositionProfile		:	MC_PositionProfile;			//NOT IMPLEMENTED		//37
	//MCVelocityProfile		:	MC_VelocityProfile;			//NOT IMPLEMENTED		//38
	//MCAccelerationProfile	:	MC_AccelerationProfile;		//NOT IMPLEMENTED		//39
	MCGearIn				:	MC_GearIn;											//40
	MCGearInDyn				:	MC_GearInDyn;										//41
	MCGearInMultiMaster		:	MC_GearInMultiMaster;								//42	
	MCGearOut				:	MC_GearOut;											//43
	
	MCHaltPhasing			:	MC_HaltPhasing;										//44
	MCPhasingAbsolute		:	MC_PhasingAbsolute;									//45
	MCPhasingRelative		:	MC_PhasingRelative;									//46
	
	//CAMMING
	MCCamIn					:	MC_CamIn;											//47
	MCCamOut				:	MC_CamOut;											//48
	MCCamScaling			:	MC_CamScaling;										//49
	//MULTICAMMING	
	MCCamAdd				:	MC_CamAdd;											//50
	MCCamExchange			:	MC_CamExchange;										//51
	MCCamInV2				:	MC_CamIn_V2;		//REQUIRED FOR MULTICAMMING 	//52	//do not use MC_CamIn
	MCCamRemove				:	MC_CamRemove;										//53
	MCCamScalingV2			:	MC_CamScaling_V2;									//54
	
	
				
			
	
	

	//MOTION
	
	//MCHomeRef	:	MC_StepReferencePulse;
	//MCHomeLim	:	MC_StepLimitSwitch;
	//MCHomeAbs	:	MC_StepAbsoluteSwitch;
	//homingSw	:	MC_Ref_Signal_Ref;
	//homingStruct:	MC_HomingParameter;
	

	
	
	iState			: 	UINT;
	
	Status: INT;	

	Done: INT;
END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[AxisController.AXIS.ReadStatus();
bTest:= uCommand=2;
heartBeat:= heartBeat+1;


//////////////////////////////////////
//				FLAGS				//
//////////////////////////////////////
AxisController.axisReady:= AxisController.AXIS.Status.Operational;
AxisController.bMOVING:=AxisController.AXIS.Status.Moving;

//LATCH ON THE COMMAND SIGNAL - NOT SURE ABOUT THIS. NEED GUI TO TEST BETTER
IF NOT AxisController.AXIS.Status.HasJob THEN	
	uCommand:=AxisController.COMMAND;
END_IF


//////////////////////////////////////
//			AXIS STATES				//
//////////////////////////////////////
IF AxisController.AXIS.Status.Disabled THEN
	AxisController.AXISSTATE:=		100;
ELSIF AxisController.AXIS.Status.StandStill THEN
	AxisController.AXISSTATE:=		200;
ELSIF AxisController.AXIS.Status.Homing	THEN
	AxisController.AXISSTATE:= 	300;
ELSIF AxisController.AXIS.Status.DiscreteMotion	THEN
	AxisController.AXISSTATE:=		400;
ELSIF AxisController.AXIS.Status.SynchronizedMotion	THEN
	AxisController.AXISSTATE:=		500;
ELSIF AxisController.AXIS.Status.ContinuousMotion	THEN
	AxisController.AXISSTATE:=		600;
ELSIF AxisController.AXIS.Status.Stopping	THEN
	AxisController.AXISSTATE:= 	700;	
ELSIF AxisController.AXIS.Status.Error THEN
	AxisController.AXISSTATE:=		999;	
ELSE
	AxisController.AXISSTATE:=		0;
END_IF

//Power run outside of commands as need to watch limits
MCPower(
	Axis:=AxisController.AXIS,
	Enable:=AxisController.bENABLE,
	Enable_Positive:=AxisController.bEnFW,
	Enable_Negative:=AxisController.bEnBW,
	Override:=AxisController.OVERRIDE,
	Status=>,
	Busy=>,
	Active=>,
	Error=>,
	ErrorID=>
);

//READ PARAMETERS OUTSIDE OF CASE STATEMENTS

//OR COULD I DO THIS WITH A CASE iPARAM that incremented iParam with each .Done signal?
//CASE iParam OF
// 1: //is it worth it if I'm going to have to false every execute? 
MCReadParameter(Axis:=AxisController.AXIS,ParameterNumber:=iParam);
IF MCReadParameter.Valid THEN
	MCReadParameter(Axis:=AxisController.AXIS,Enable:=FALSE);
	AxisController.PARAMETERSOUT[iParam]:=MCReadParameter.Value;
	iParam:= iParam+1;
	IF iParam>17 THEN
		iParam:=1;
	END_IF
ELSE
	MCReadParameter(Axis:=AxisController.AXIS,Enable:=TRUE);
END_IF
IF AxisController.PARAMETERSOUT[RWParameter.EnableLimitPos]=1 THEN
	AxisController.bSwLimPosEn:=TRUE;
	ELSE
		AxisController.bSwLimPosEn:=FALSE;
END_IF
IF AxisController.PARAMETERSOUT[RWParameter.EnableLimitNeg]=1 THEN
	AxisController.bSwLimNegEn:=TRUE;
	ELSE
		AxisController.bSwLimNegEn:=FALSE;
END_IF
IF AxisController.PARAMETERSOUT[RWParameter.EnablePosLagMonitoring]=1 THEN
	AxisController.bPosLagEn:=TRUE;
	ELSE
		AxisController.bPosLagEn:=FALSE;
END_IF



////////////////////////////////////////////


CASE uCommand OF
	1:		//RESET
	MCReset(
		Axis:=AxisController.AXIS,
		Execute:=AxisController.bRESET, 
		Done=>	,
		Busy=>	,
		Error=>	,
		ErrorID=>	,
		);
		//Might put this in FB after testing
		IF AxisController.bRESET=TRUE THEN
			bDone:=MCReset.Done;
			AxisController.bBUSY:=MCReset.Busy;
			AxisController.bERROR:=MCReset.Error;
			AxisController.ERRORID:=MCReset.ErrorID;
			AxisController.bEXECUTE:= NOT(MCReset.Done);
			AxisController.bRESET:=FALSE;
		END_IF	
	///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	2:		//POWER
		IF AxisController.bENABLE THEN
			AxisController.axisReady:=MCPower.Active;
			AxisController.bBUSY:=MCPower.Busy;
			AxisController.bERROR:=MCPower.Error;
			AxisController.ERRORID:=MCPower.ErrorID;
		END_IF		
	///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////	
	3:		//READ STATUS
			//OUTSIDE OF STATE MACHINE
	
	///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	4:		//READ AXIS ERROR
	
	///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	5:		//READ PARAMETER
			//OUTSIDE OF STATE MACHINE
	
	
	///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	6:		//READ BOOL PARAMETER
			//NOT IMPLEMENTED
	
	///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	7:		//WRITE PARAMETER		
		MCWriteParameter(
			Axis:=AxisController.AXIS,
			Execute:=AxisController.bEXECUTE,
			ParameterNumber:=AxisController.iPARAMSET,
			Value:= AxisController.PARAMVALUE,
			Done=>bDone,
			Busy=>AxisController.bBUSY,
			Error=>AxisController.bERROR,
			ErrorID=>AxisController.ERRORID
			);
		executeTrig(CLK:=MCWriteParameter.Done OR MCWriteParameter.Error);//NOT(MCMoveAbsolute.Done);
		IF executeTrig.Q THEN
			AxisController.bEXECUTE:= FALSE;
			MCWriteParameter(Axis:=AxisController.AXIS,Execute:=AxisController.bEXECUTE);
		END_IF
			
	
	///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	8:		//WRITE BOOL PARAMETER		
		MCWriteBoolParameter(
			Axis:=AxisController.AXIS,
			Execute:=AxisController.bEXECUTE,
			ParameterNumber:=AxisController.iPARAMSET,
			Value:=AxisController.bINPUT,
			Done=>bDone,
			Busy=>AxisController.bBUSY,
			Error=>AxisController.bERROR,
			ErrorID=>AxisController.ERRORID
			);
			executeTrig(CLK:=MCWriteBoolParameter.Done OR MCWriteBoolParameter.Error);
			IF executeTrig.Q THEN
				AxisController.bEXECUTE:= FALSE;
				MCWriteBoolParameter(Axis:=AxisController.AXIS,Execute:=AxisController.bEXECUTE);
			END_IF
	
	///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	9:		//READ DIGITAL INPUT - NOT IMPLEMENTED IN BECKHOFF
	
	///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	10:		//READ DIGITAL OUTPUT - NOT IMPLEMENTED IN BECKHOFF
	
	///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	11:		//WRITE DIGITAL OUTPUT - NOT IMPLEMENTED IN BECKHOFF
	
	///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	12:		//READ ACTUAL POSITION
	13:		//READ ACTUAL VELOCITY
	14:		//READ ACTUAL TORQUE - NOT IMPLEMENTED IN BECKHOFF
	15:		//READ AXIS INFO - NOT IMPLEMENTED IN BECKHOFF
	16:		//READ MOTION STATE - NOT IMPLEMENTED IN BECKHOFF
	17:		//SET POSITION
	18:		//SET OVERRIDE
	19:		//TOUCH PROBE
	20:		//DIGITAL CAM SWITCH - NOT IMPLEMENTED IN BECKHOFF
	21:		//ABORT TRIGGER
	22:		//ABORT SUPERPOSITION - HALT SUPERIMPOSED IN STANDARD
	23:		//CAM TABLE SELECT
	24:		//HOME
	25:		//JOG
	26:		//STOP
	27:		//HALT
	28:		//MOVE ABSOLUTE
		MCMoveAbsolute(	
			Axis:=AxisController.AXIS,
			Execute:=AxisController.bEXECUTE,
			Position:=	AxisController.POSITION,
			Velocity:= AxisController.VELOCITY,
			Acceleration:= ,
			Deceleration:= ,
			Jerk:= ,
			BufferMode:=,
			Options:=,
			Done=>bDone,
			Busy=>AxisController.bBUSY,
			Active=>,
			CommandAborted=>,
			Error=>AxisController.bERROR,
			ErrorID=>AxisController.ERRORID
		);
		
		executeTrig(CLK:=MCMoveAbsolute.Done OR MCMoveAbsolute.Error);
		IF executeTrig.Q THEN
			AxisController.bEXECUTE:= FALSE;
			MCMoveAbsolute(Axis:=AxisController.AXIS,Execute:=AxisController.bEXECUTE);
		END_IF
	///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	29:		//MOVE RELATIVE
		MCMoveRelative(	
			Axis:=AxisController.AXIS,
			Execute:=AxisController.bEXECUTE,
			Distance:= AxisController.DISTANCE,
			Velocity:= AxisController.VELOCITY,
			Acceleration:= ,
			Deceleration:= ,
			Jerk:= ,
			BufferMode:=,
			Options:=,
			Done=>bDone,
			Busy=>AxisController.bBUSY,
			Active=>,
			CommandAborted=>,
			Error=>AxisController.bERROR,
			ErrorID=>AxisController.ERRORID
		);
		executeTrig(CLK:=(MCMoveRelative.Done OR MCMoveRelative.Error));
		//executeTrig(CLK:=MCMoveRelative.Error);
		IF executeTrig.Q THEN
			AxisController.bEXECUTE:= FALSE;
			MCMoveRelative(Axis:=AxisController.AXIS,Execute:=AxisController.bEXECUTE);
		END_IF
		
	///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	30:		//MOVE ADDITIVE
	31:		//MOVE SUPERIMPOSED
	32:		//MOVE VELOCITY
	33:		//MOVE CONTINUOUS ABSOLUTE
	34:		//MOVE CONTINUOUS RELATIVE
	35:		//MOVE MODULO
	36:		//TORQUE CONTROL - NOT IMPLEMENTED IN BECKHOFF
	37:		//POSITION PROFILE - NOT IMPLEMENTED IN BECKHOFF
	38:		//VELOCITY PROFILE - NOT IMPLEMENTED IN BECKHOFF
	39:		//ACCELERATION PROFILE - NOT IMPLEMENTED IN BECKHOFF
	40:		//GEAR IN
		MCGearIn(
			Master:=	AxisController.MASTERAXIS,
			Slave:=		AxisController.AXIS,
			Execute:=	AxisController.bEXECUTE,
			RatioNumerator:=	AxisController.ratioNUM,
			RatioDenominator:=	AxisController.ratioDEN,
			Acceleration:=		,
			Deceleration:=		,
			Jerk:=				,
			BufferMode:=		,
			Options:=			,
			InGear=>	,
			Busy=>		AxisController.bBUSY,
			Active=>	bDone,
			CommandAborted=>	,
			Error=>		AxisController.bERROR,
			ErrorID=>	AxisController.ERRORID
		);
		executeTrig(CLK:=MCGearIn.Active OR MCGearIn.Error);
		IF executeTrig.Q THEN
			AxisController.bEXECUTE:= FALSE;
		END_IF
		
	///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	41:		//GEAR IN DYNAMIC
	42:		//GEAR IN MULTI-MASTER
		MCGearInMultiMaster(
			Master1:= AxisController.MASTERAXIS1,
			Master2:= AxisController.MASTERAXIS2,
			Master3:= AxisController.MASTERAXIS3,
			Master4:= AxisController.MASTERAXIS4,
			Slave:= AxisController.AXIS,
			Enable:= AxisController.bEXECUTE,
			GearRatio1:= AxisController.GEARRATIO1,
			GearRatio2:= AxisController.GEARRATIO2,
			GearRatio3:= AxisController.GEARRATIO3,
			GearRatio4:= AxisController.GEARRATIO4,
			Acceleration:=		,
			Deceleration:=		,
			Jerk:=				,
			BufferMode:=		,
			Options:=			,
			InGear=>	,
			Busy=>		AxisController.bBUSY,
			Active=>	bDone,
			CommandAborted=>	,
			Error=>		AxisController.bERROR,
			ErrorID=>	AxisController.ERRORID
			
			);
	43:		//GEAR OUT
		MCGearOut(
			Slave:=		AxisController.AXIS,
			Execute:=	AxisController.bEXECUTE,
			Options:= ,
			Done=>		bDone,
			Busy=>		AxisController.bBUSY,
			Error=>		AxisController.bERROR,
			ErrorID=>	AxisController.ERRORID
		);
		executeTrig(CLK:=MCGearOut.Done OR MCGearOut.Error);
		IF executeTrig.Q THEN
			AxisController.bEXECUTE:= FALSE;
		END_IF	
	///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////	
	44:		//HALT PHASING
	45:		//PHASING ABSOLUTE
	46:		//PHASING RELATIVE
	47:		//CAM IN
	48:		//CAM OUT
	49:		//CAM SCALING
	50:		//CAM ADD
	51:		//CAM EXCHANGE
	52:		//CAM IN V2 - USE FOR MULTI CAMMING
	53:		//CAM REMOVE
	54:		//CAM SCALING V2
	
		
		
		
END_CASE



//Logic to latch on the done signal. As per the standard, unless the execute line is held high, there will be no done 
//output, so this latches that signal the one cycle it is on.
doneLatch(SET1:=bDone,RESET:=AxisController.bBUSY);
AxisController.latchDONE:=doneLatch.Q1;

errorLatch(SET1:=AxisController.bERROR, RESET:=AxisController.bBUSY);
AxisController.latchERROR:=errorLatch.Q1;
			

//bExecute:= FALSE; //Issue with this is you'll never receive a done signal unless execute is held high]]></ST>
    </Implementation>
    <LineIds Name="AxDriveFB_V3">
      <LineId Id="147" Count="0" />
      <LineId Id="379" Count="0" />
      <LineId Id="354" Count="0" />
      <LineId Id="980" Count="1" />
      <LineId Id="984" Count="0" />
      <LineId Id="982" Count="0" />
      <LineId Id="985" Count="0" />
      <LineId Id="383" Count="0" />
      <LineId Id="808" Count="0" />
      <LineId Id="976" Count="1" />
      <LineId Id="565" Count="0" />
      <LineId Id="975" Count="0" />
      <LineId Id="974" Count="0" />
      <LineId Id="978" Count="1" />
      <LineId Id="987" Count="1" />
      <LineId Id="986" Count="0" />
      <LineId Id="568" Count="0" />
      <LineId Id="574" Count="1" />
      <LineId Id="577" Count="1" />
      <LineId Id="581" Count="5" />
      <LineId Id="1128" Count="1" />
      <LineId Id="1126" Count="1" />
      <LineId Id="587" Count="1" />
      <LineId Id="569" Count="0" />
      <LineId Id="438" Count="0" />
      <LineId Id="666" Count="0" />
      <LineId Id="1376" Count="0" />
      <LineId Id="1365" Count="10" />
      <LineId Id="1703" Count="0" />
      <LineId Id="1705" Count="0" />
      <LineId Id="1727" Count="0" />
      <LineId Id="1706" Count="0" />
      <LineId Id="1770" Count="1" />
      <LineId Id="1773" Count="0" />
      <LineId Id="1780" Count="6" />
      <LineId Id="1778" Count="1" />
      <LineId Id="1777" Count="0" />
      <LineId Id="1945" Count="1" />
      <LineId Id="1948" Count="12" />
      <LineId Id="1947" Count="0" />
      <LineId Id="1715" Count="0" />
      <LineId Id="1707" Count="1" />
      <LineId Id="1704" Count="0" />
      <LineId Id="595" Count="0" />
      <LineId Id="1173" Count="0" />
      <LineId Id="591" Count="0" />
      <LineId Id="1456" Count="7" />
      <LineId Id="1472" Count="0" />
      <LineId Id="1464" Count="7" />
      <LineId Id="1345" Count="0" />
      <LineId Id="1273" Count="0" />
      <LineId Id="1338" Count="6" />
      <LineId Id="1274" Count="0" />
      <LineId Id="1701" Count="0" />
      <LineId Id="1347" Count="0" />
      <LineId Id="1346" Count="0" />
      <LineId Id="1275" Count="0" />
      <LineId Id="1348" Count="1" />
      <LineId Id="1276" Count="0" />
      <LineId Id="2121" Count="0" />
      <LineId Id="1702" Count="0" />
      <LineId Id="1350" Count="1" />
      <LineId Id="1277" Count="0" />
      <LineId Id="2122" Count="0" />
      <LineId Id="1352" Count="1" />
      <LineId Id="1278" Count="0" />
      <LineId Id="1787" Count="9" />
      <LineId Id="1974" Count="2" />
      <LineId Id="1978" Count="0" />
      <LineId Id="1977" Count="0" />
      <LineId Id="1797" Count="0" />
      <LineId Id="1354" Count="1" />
      <LineId Id="1279" Count="0" />
      <LineId Id="1935" Count="9" />
      <LineId Id="1979" Count="2" />
      <LineId Id="1987" Count="0" />
      <LineId Id="1982" Count="0" />
      <LineId Id="1356" Count="1" />
      <LineId Id="1280" Count="0" />
      <LineId Id="1358" Count="1" />
      <LineId Id="1281" Count="0" />
      <LineId Id="1360" Count="1" />
      <LineId Id="1282" Count="0" />
      <LineId Id="1362" Count="1" />
      <LineId Id="1283" Count="16" />
      <LineId Id="1377" Count="16" />
      <LineId Id="1593" Count="0" />
      <LineId Id="1394" Count="0" />
      <LineId Id="1400" Count="1" />
      <LineId Id="1988" Count="0" />
      <LineId Id="1402" Count="0" />
      <LineId Id="1404" Count="0" />
      <LineId Id="1300" Count="0" />
      <LineId Id="1969" Count="0" />
      <LineId Id="1406" Count="15" />
      <LineId Id="1989" Count="3" />
      <LineId Id="1994" Count="0" />
      <LineId Id="1993" Count="0" />
      <LineId Id="1427" Count="0" />
      <LineId Id="1431" Count="0" />
      <LineId Id="1301" Count="10" />
      <LineId Id="1433" Count="21" />
      <LineId Id="1700" Count="0" />
      <LineId Id="1455" Count="0" />
      <LineId Id="1312" Count="1" />
      <LineId Id="2249" Count="4" />
      <LineId Id="2255" Count="2" />
      <LineId Id="2259" Count="13" />
      <LineId Id="2258" Count="0" />
      <LineId Id="2254" Count="0" />
      <LineId Id="1314" Count="0" />
      <LineId Id="1473" Count="13" />
      <LineId Id="1315" Count="10" />
      <LineId Id="593" Count="0" />
      <LineId Id="618" Count="0" />
      <LineId Id="615" Count="0" />
      <LineId Id="594" Count="0" />
      <LineId Id="592" Count="0" />
      <LineId Id="385" Count="0" />
      <LineId Id="800" Count="3" />
      <LineId Id="398" Count="0" />
      <LineId Id="668" Count="0" />
      <LineId Id="404" Count="0" />
      <LineId Id="1963" Count="1" />
      <LineId Id="405" Count="0" />
      <LineId Id="390" Count="0" />
      <LineId Id="355" Count="0" />
      <LineId Id="9" Count="0" />
    </LineIds>
  </POU>
</TcPlcObject>