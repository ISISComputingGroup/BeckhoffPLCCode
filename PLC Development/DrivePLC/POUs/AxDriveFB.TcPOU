<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4022.12">
  <POU Name="AxDriveFB" Id="{aef7aef0-3971-449b-83a3-6f8c4c2f7d04}" SpecialFunc="None">
    <Declaration><![CDATA[FUNCTION_BLOCK AxDriveFB
VAR_INPUT

END_VAR
VAR_IN_OUT
	AxisController		:	ST_AxisControl;
END_VAR
VAR_OUTPUT

END_VAR
VAR
	eCommandLatched		:	eMcCommand;		//Internally latched command signal, new commands cannot be issued until existing commands have completed.
											//This may need to change for sequencing
	doneLatch	:	SR;			//Used to set done signal in AxisController DUT
	bError		:	BOOL;		//Not currently implemented but may be used in future similar to bDone once more error management is implemented
	bDone		:	BOOL;		//Interal done flag which will be used for latching on an external done located in AxisController DUT
	iParam		:	INT:=1;		//index of NC parameters FBs, no 0 index on array so initialised to 1
	iIndex		:	UINT;		//index value used for limit coupling
	iMasterIndex		:	UINT;
	
	//Boolean to store EnableFw and EnableBw of MCPower FB
	FwLimitsEnabled	:	BOOL;	
	BWLimitsEnabled	:	BOOL;

//FBs as defined by PLC Open Standard
//Functions that are commented out have not been implemented yet, any listed as "NOT IMPLEMENTED" are not in the Beckhoff P2P library
	//ADMIN                                                                         
	MCReset						:	MC_Reset;											
	MCPower						:	MC_Power;										
	//MCReadStatus				:	MC_ReadStatus;					//Same as Axis.ReadStatus();						
	//MCReadAxisError			:	MC_ReadAxisError;									
	MCReadParameter				:	MC_ReadParameter;									
	//MCReadBoolParameter		:	MC_ReadBoolParameter;			//not required, can be covered be McReadParameter						
	MCWriteParameter			:	MC_WriteParameter;										
	MCWriteBoolParameter		:	MC_WriteBoolParameter;								
	//MCReadDigitalInput		:	MC_ReadDigitalInput;			//NOT IMPLEMENTED		
	//MCReadDigitalOutput		:	MC_ReadDigitalOutput;			//NOT IMPLEMENTED	
	//MCWriteDigitalOutput		:	MC_WriteDigitalOutput;			//NOT IMPLEMENTED	
	//MCReadActualPosition		:	MC_ReadActualPosition;								
	//MCReadActualVelocity		:	MC_ReadActualVelocity;								
	//MCReadActualTorque		:	MC_ReadActualTorque;			//NOT IMPLEMENTED	
	//MCReadAxisInfo			:	MC_ReadAxisInfo;				//NOT IMPLEMENTED	
	//MCReadMotionState			:	MC_ReadMotionState;				//NOT IMPLEMENTED	
	MCSetPosition				:	MC_SetPosition;										
	//MCSetOverride				:	MC_SetOverride;										
	//MCTouchProbe				:	MC_TouchProbe;										
	//MCDigitalCamSwitch		:	MC_DigitalCamSwitch;			//NOT IMPLEMENTED	
	//MCAbortTrigger			:	MC_AbortTrigger;									
	//MCAbortSuperposition		:	MC_AbortSuperposition;			//HaltSuperimposed?	
	//MCCamTableSelect			:	MC_CamTableSelect;									
	
	//MCHome					:	MC_Home;											
	MCJog						:	MC_Jog;												
	MCStop					:	MC_Stop;											
	////////MCHalt					:	MC_Halt;											
	MCMoveAbsolute				:	MC_MoveAbsolute;									
	MCMoveRelative				:	MC_MoveRelative;									
	//MCMoveAdditive			:	MC_MoveAdditive;									
	//MCMoveSuperimposed		:	MC_MoveSuperimposed;								
	MCMoveVelocity			:	MC_MoveVelocity;									
	//MCMoveContinuousAbsolute	:	MC_MoveContinuousAbsolute;						
	//MCMoveContinuousRelative	:	MC_MoveContinuousRelative;						
	////////MCMoveModulo				:	MC_MoveModulo;										
	//MCTorqueControl			:	MC_TorqueControl;			//NOT IMPLEMENTED		
	//MCPositionProfile			:	MC_PositionProfile;			//NOT IMPLEMENTED		
	//MCVelocityProfile			:	MC_VelocityProfile;			//NOT IMPLEMENTED		
	//MCAccelerationProfile		:	MC_AccelerationProfile;		//NOT IMPLEMENTED		
	MCGearIn					:	MC_GearIn;											
	//MCGearInDyn				:	MC_GearInDyn;										
	MCGearInMultiMaster			:	MC_GearInMultiMaster;								
	MCGearOut					:	MC_GearOut;												                                                                                    
	//MCHaltPhasing				:	MC_HaltPhasing;										
	//MCPhasingAbsolute			:	MC_PhasingAbsolute;									
	//MCPhasingRelative			:	MC_PhasingRelative;										                                                                                                                                                 
	//MCCamIn					:	MC_CamIn;											
	//MCCamOut					:	MC_CamOut;											
	//MCCamScaling				:	MC_CamScaling;										                                                      
	//MCCamAdd					:	MC_CamAdd;											
	//MCCamExchange				:	MC_CamExchange;										
	//MCCamInV2					:	MC_CamIn_V2;		//REQUIRED FOR MULTICAMMING 	
	//MCCamRemove				:	MC_CamRemove;										
	//MCCamScalingV2			:	MC_CamScaling_V2;									

	//HOMING AND HOMING STEPS
	MCFinishHoming	:	MC_FinishHoming;
	//MCHomeDirect		:	MC_HomeDirect;
	//MCAbortHoming		:	MC_AbortHoming;
	MCStepAbsoluteSwitch	:	MC_StepAbsoluteSwitch;
	//MCStepBlock			:	MC_StepBlock;
	//MCStepBlockLagBased	:	MC_StepBlockLagBased;
	//MCStepLimitSwitch		:	MC_StepLimitSwitch;
	//MCStepReferencePulse	:	MC_StepReferencePulse;
	
	
	//MCSignalRef			:	MC_Ref_Signal_Ref;

	StOptions				:	ST_Home_Options;
	StOptions2				:	ST_Home_Options2;
	StOptions3				:	ST_Home_Options3;
	StOptions4				:	ST_Home_Options4;
	MCHomingParameter		:	MC_HomingParameter;		//Must be passed between homing steps.									
	
	//MCHomeRef	:	MC_StepReferencePulse;
	//MCHomeLim	:	MC_StepLimitSwitch;
	//MCHomeAbs	:	MC_StepAbsoluteSwitch;
	//homingSw	:	MC_Ref_Signal_Ref;
	//homingStruct:	MC_HomingParameter;
	
	dir	:	MC_Direction;

END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[AxisController.Axis.ReadStatus();

//////////////////////////////////////////////////////////////////////
//     _   __  _____ ____    ____ _____  _  _____ _____ ____  		//
//    / \  \ \/ |_ _/ ___|  / ___|_   _|/ \|_   _| ____/ ___| 		//
//   / _ \  \  / | |\___ \  \___ \ | | / _ \ | | |  _| \___ \ 		//
//  / ___ \ /  \ | | ___) |  ___) || |/ ___ \| | | |___ ___) |		//
// /_/   \_/_/\_|___|____/  |____/ |_/_/   \_|_| |_____|____/ 		//
// 																	//
//////////////////////////////////////////////////////////////////////
                                                            
//Numerical state for axis states - may use later for buffering functions.
IF AxisController.AXIS.Status.Disabled THEN
	AxisController.iAxisState:=		100;
ELSIF AxisController.AXIS.Status.StandStill THEN
	AxisController.iAxisState:=		200;
ELSIF AxisController.AXIS.Status.Homing	THEN
	AxisController.iAxisState:= 	300;
ELSIF AxisController.AXIS.Status.DiscreteMotion	THEN
	AxisController.iAxisState:=		400;
ELSIF AxisController.AXIS.Status.SynchronizedMotion	THEN
	AxisController.iAxisState:=		500;
ELSIF AxisController.AXIS.Status.ContinuousMotion	THEN
	AxisController.iAxisState:=		600;
ELSIF AxisController.AXIS.Status.Stopping	THEN
	AxisController.iAxisState:= 	700;	
ELSIF AxisController.AXIS.Status.Error THEN
	AxisController.iAxisState:=		999;	
ELSE
	AxisController.iAxisState:=		0;
END_IF

//////////////////////////////////////////////////////////////////////////////////////////
//  _     ___ __  __ ___ _____   ______        _____ _____ ____ _   _ _____ ____  		//
// | |   |_ _|  \/  |_ _|_   _| / ___\ \      / |_ _|_   _/ ___| | | | ____/ ___| 		//
// | |    | || |\/| || |  | |   \___ \\ \ /\ / / | |  | || |   | |_| |  _| \___ \ 		//
// | |___ | || |  | || |  | |    ___) |\ V  V /  | |  | || |___|  _  | |___ ___) |		//
// |_____|___|_|  |_|___| |_|   |____/  \_/\_/  |___| |_| \____|_| |_|_____|____/		//
//																						//
//////////////////////////////////////////////////////////////////////////////////////////
//Set EnableFW and EnableBW flags based on axis limit states to begin
FwLimitsEnabled :=Limits.FwLimit[GVL.iAxis];
BwLimitsEnabled :=Limits.BwLimit[GVL.iAxis];

//Allow Master axes to listen to slave axes
//Look through array structure that manages forward and backward coupling for axis, if a slave is present check whether it is
//a FW limit or BW limit that matters and compare this against the hardware status.
//This check used to use the AxisID value from the NC however this had issues as incorrectly set NC IDs would break
//A GVL is now used to check what axis we are currently running
FOR iIndex:=1 TO GVL.axisNumMax BY 1 DO
	FOR iMasterIndex:=1 TO 5 BY 1 DO
		IF Limits.coupledFwLimit[iIndex][iMasterIndex].iMasterAxis = GVL.iAxis THEN
			IF Limits.coupledFwLimit[iIndex][iMasterIndex].eLimitType=eLimitCoupling.FwSw AND NOT Limits.FwLimit[iIndex] THEN
				FwLimitsEnabled:=FALSE;
			END_IF
			IF Limits.coupledFwLimit[iIndex][iMasterIndex].eLimitType=eLimitCoupling.BwSw AND NOT Limits.BwLimit[iIndex] THEN
				FwLimitsEnabled:=FALSE;
			END_IF
			IF Limits.coupledBwLimit[iIndex][iMasterIndex].eLimitType=eLimitCoupling.FwSw AND NOT Limits.FwLimit[iIndex] THEN
				BwLimitsEnabled:=FALSE;
			END_IF
			IF Limits.coupledBwLimit[iIndex][iMasterIndex].eLimitType=eLimitCoupling.BwSw AND NOT Limits.BwLimit[iIndex] THEN
				BwLimitsEnabled:=FALSE;
			END_IF
		END_IF
	END_FOR
END_FOR

AxisController.bFwEnabled:=FwLimitsEnabled;		//STATUS FEEDBACK
AxisController.bBwEnabled:=BwLimitsEnabled;		//STATUS FEEDBACk







//////////////////////////////////////////////////////////
//  ____   _____        _______ ____    _   _ ____  	//
// |  _ \ / _ \ \      / | ____|  _ \  | | | |  _ \ 	//
// | |_) | | | \ \ /\ / /|  _| | |_) | | | | | |_) |	//
// |  __/| |_| |\ V  V / | |___|  _ <  | |_| |  __/ 	//
// |_|    \___/  \_/\_/  |_____|_| \_\  \___/|_|   		//
//														//
/////////////////////////////////////////////////////////// 
                                               
MCPower(
	Axis:=AxisController.Axis,
	Enable:=AxisController.bEnable,
	Enable_Positive:=FwLimitsEnabled,
	Enable_Negative:=BwLimitsEnabled,
	Override:=AxisController.fOverride,
	Status=>,
	Busy=>, 
	Active=>AxisController.bAxisReady,	//Maybe want a bPowered or bEnabled flag instead?
	Error=>,
	ErrorID=>
);


//////////////////////////////////////////////////////////////////////////////////////////////////////////
//  ____  _____    _    ____    ____   _    ____     _    __  __ _____ _____ _____ ____  ____  			//
// |  _ \| ____|  / \  |  _ \  |  _ \ / \  |  _ \   / \  |  \/  | ____|_   _| ____|  _ \/ ___| 			//
// | |_) |  _|   / _ \ | | | | | |_) / _ \ | |_) | / _ \ | |\/| |  _|   | | |  _| | |_) \___ \ 			//
// |  _ <| |___ / ___ \| |_| | |  __/ ___ \|  _ < / ___ \| |  | | |___  | | | |___|  _ < ___) |			//
// |_| \_|_____/_/   \_|____/  |_| /_/   \_|_| \_/_/   \_|_|  |_|_____| |_| |_____|_| \_|____/ 			//
//                                                                                           			//
//////////////////////////////////////////////////////////////////////////////////////////////////////////
//Read in motion parameters: cycle through the 17 available
MCReadParameter(Axis:=AxisController.AXIS,ParameterNumber:=iParam);
IF MCReadParameter.Valid THEN
	MCReadParameter.Enable:=FALSE;
	AxisController.fParameters[iParam]:=MCReadParameter.Value;
	iParam:= iParam+1;
	IF iParam>17 THEN
		iParam:=1;
	END_IF
ELSE
	MCReadParameter.Enable:=TRUE;
END_IF

//To save on using a separate bool parameter read just converting the REALs to BOOLS and storing in flags
IF AxisController.fParameters[eRWParameter.EnableLimitPos]=1 THEN
	AxisController.bSoftLimPosEn:=TRUE;
ELSE
	AxisController.bSoftLimPosEn:=FALSE;
END_IF

IF AxisController.fParameters[eRWParameter.EnableLimitNeg]=1 THEN
	AxisController.bSoftLimNegEn:=TRUE;
ELSE
	AxisController.bSoftLimNegEn:=FALSE;
END_IF

IF AxisController.fParameters[eRWParameter.EnablePosLagMonitoring]=1 THEN
	AxisController.bPosLagEn:=TRUE;
ELSE
	AxisController.bPosLagEn:=FALSE;
END_IF

//////////////////////////////////////////////////////////////////////////////////////////////////////////
//  __  __  ____   _____ _   _ _   _  ____ _____ ___ ___  _   _    ____    _    _     _     ____  		//
// |  \/  |/ ___| |  ___| | | | \ | |/ ___|_   _|_ _/ _ \| \ | |  / ___|  / \  | |   | |   / ___| 		//
// | |\/| | |     | |_  | | | |  \| | |     | |  | | | | |  \| | | |     / _ \ | |   | |   \___ \ 		//
// | |  | | |___  |  _| | |_| | |\  | |___  | |  | | |_| | |\  | | |___ / ___ \| |___| |___ ___) |		//
// |_|  |_|\____| |_|    \___/|_| \_|\____| |_| |___\___/|_| \_|  \____/_/   \_|_____|_____|____/ 		//
//                                         																//                                                      
//////////////////////////////////////////////////////////////////////////////////////////////////////////
//Call MC Function Blocks and clear execute signals
//Function blocks will hold done and error signals for 1 cycle with no execute held
MCReadParameter(Axis:=AxisController.Axis);	//Reading in motion parameters, using one functionblock for all params means need to disable
MCReset(Axis:=AxisController.Axis);
MCReset.Execute:=FALSE;
MCWriteParameter(Axis:=AxisController.Axis);
MCWriteParameter.Execute:=FALSE;
MCWriteBoolParameter(Axis:=AxisController.Axis);
MCWriteBoolParameter.Execute:=FALSE;
MCSetPosition(Axis:=AxisController.Axis);
MCSetPosition.Execute:=FALSE;
MCMoveAbsolute(Axis:=AxisController.Axis);
MCMoveAbsolute.Execute:=FALSE;
MCMoveRelative(Axis:=AxisController.Axis);
MCMoveRelative.Execute:=FALSE;

MCGearIn(Slave:=AxisController.Axis, Master:=GVL.axes[AxisController.masterAxis].Axis);
MCGearIn.Execute:=FALSE;
MCGearInMultiMaster(Master1:=GVL.axes[AxisController.masterAxes[1].i].Axis,Master2:=GVL.axes[AxisController.masterAxes[2].i].Axis,Master3:=GVL.axes[AxisController.masterAxes[3].i].Axis,Master4:=GVL.axes[AxisController.masterAxes[4].i].Axis,Slave:=AxisController.Axis);
MCGearInMultiMaster.Enable:=FALSE;	//NOT EXECUTE AS FB ALLOWS CONTINUAL UPDATING OF RATIOS WHILST ENABLED, testing move here
MCGearOut(Slave:=AxisController.Axis);
MCGearOut.Execute:=FALSE;

MCJog(Axis:=AxisController.Axis);
MCJog.JogBackwards:=FALSE;
MCJog.JogForward:=FALSE;
MCStepAbsoluteSwitch(Axis:=AxisController.Axis,Parameter:=MCHomingParameter);
MCStepAbsoluteSwitch.Execute:=FALSE;
MCFinishHoming(Axis:=AxisController.Axis,Parameter:=MCHomingParameter);
MCFinishHoming.Execute:=FALSE;

MCMoveVelocity(Axis:=AxisController.Axis);
MCMoveVelocity.Execute:=FALSE;

MCStop(Axis:=AxisController.Axis);
MCStop.Execute:=FALSE;

//If we're not doing anything or have just done something we no longer latch on the given command
IF NOT AxisController.AXIS.Status.HasJob OR AxisController.bDone THEN
	eCommandLatched:=AxisController.eCommand;
END_IF



//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//   ____ ___  __  __ __  __    _    _   _ ____     ____    _    ____  _____   ____ _____  _  _____ _____ __  __ _____ _   _ _____ ____ 	// 
//  / ___/ _ \|  \/  |  \/  |  / \  | \ | |  _ \   / ___|  / \  / ___|| ____| / ___|_   _|/ \|_   _| ____|  \/  | ____| \ | |_   _/ ___| 	//
// | |  | | | | |\/| | |\/| | / _ \ |  \| | | | | | |     / _ \ \___ \|  _|   \___ \ | | / _ \ | | |  _| | |\/| |  _| |  \| | | | \___ \ 	//
// | |__| |_| | |  | | |  | |/ ___ \| |\  | |_| | | |___ / ___ \ ___) | |___   ___) || |/ ___ \| | | |___| |  | | |___| |\  | | |  ___) |	//
//  \____\___/|_|  |_|_|  |_/_/   \_|_| \_|____/   \____/_/   \_|____/|_____| |____/ |_/_/   \_|_| |_____|_|  |_|_____|_| \_| |_| |____/	//
//																																			//
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CASE eCommandLatched OF
	
	eMcCommand.Idle:
		AxisController.bBusy	:=FALSE;
		AxisController.bExecute	:=FALSE;
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////	
	eMcCommand.Reset:
		AxisController.bError	:=FALSE;
		MCReset.Execute:=AxisController.bReset;
		bDone:=McReset.Done;
		AxisController.bBusy:=MCReset.Busy;
		IF MCReset.Error THEN
			AxisController.bError:=TRUE;
			AxisController.iErrorID:=MCReset.ErrorID;	
		END_IF
		
		//Clear command and erase reset flag.
		IF NOT MCReset.Busy THEN
			eCommandLatched:=eMcCommand.Idle;
			AxisController.bReset:=FALSE;
		END_IF
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	eMcCommand.WriteParameter:		
		MCWriteParameter.Execute:=AxisController.bExecute;
		MCWriteParameter.ParameterNumber:=AxisController.iParameterIndex;
		MCWriteParameter.Value:=AxisController.fParameterValue;
		bDone:=MCWriteParameter.Done;
		AxisController.bBusy:= MCWriteParameter.Busy;
		IF MCWriteParameter.Error THEN
			AxisController.bError:=TRUE;
			AxisController.iErrorID:=MCWriteParameter.ErrorID;	
		END_IF
		
		IF NOT MCWriteParameter.Busy THEN
			eCommandLatched:=eMcCommand.Idle;
		END_IF			
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	eMcCommand.WriteBoolParameter:	
		MCWriteBoolParameter.Execute:=AxisController.bExecute;
		MCWriteBoolParameter.ParameterNumber:=AxisController.iParameterIndex;
		MCWriteBoolParameter.Value:=AxisController.bInput;
		bDone:=MCWriteBoolParameter.Done;
		AxisController.bBusy:=MCWriteBoolParameter.Busy;
		
		IF MCWriteBoolParameter.Error THEN
			AxisController.bError:= TRUE;
			AxisController.iErrorID:=MCWriteBoolParameter.ErrorID;
		END_IF
				
		IF NOT MCWriteBoolParameter.Busy THEN
			eCommandLatched:=eMcCommand.Idle;
		END_IF	
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	eMcCommand.SetPosition:	
		MCSetPosition.Execute:=AxisController.bExecute;
		MCSetPosition.Position:=AxisController.fPosition;
		AxisController.bBusy:=MCSetPosition.Busy;
		bDone:=MCSetPosition.Done;
		IF MCSetPosition.Error THEN
			AxisController.bError:=TRUE;
			AxisController.iErrorID:= MCSetPosition.ErrorID;
		END_IF
		IF NOT MCSetPosition.Busy THEN
			eCommandLatched:=eMcCommand.Idle;
		END_IF
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	eMcCommand.MoveAbsolute:	
		MCMoveAbsolute.Execute:=AxisController.bExecute;
		MCMoveAbsolute.Position:=AxisController.fPosition;
		MCMoveAbsolute.Velocity:=AxisController.fVelocity;
		MCMoveAbsolute.Acceleration:=AxisController.fAcceleration;
		MCMoveAbsolute.Deceleration:=AxisController.fDeceleration;
		MCMoveAbsolute.Jerk:=0;
		MCMoveAbsolute.BufferMode:=MC_BufferMode.MC_Buffered;
		
		bDone:=MCMoveAbsolute.Done;
		AxisController.bBusy:=MCMoveAbsolute.Busy;
		
		IF MCMoveAbsolute.Error THEN
			AxisController.bError:=TRUE;
			AxisController.iErrorID:=MCMoveAbsolute.ErrorID;
		END_IF
		IF NOT MCMoveAbsolute.Busy THEN
			eCommandLatched:=eMcCommand.Idle;
		END_IF
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	eMcCommand.MoveRelative:		//MOVE RELATIVE
		MCMoveRelative.Execute:=AxisController.bExecute;
		MCMoveRelative.Distance:=AxisController.fDistance;
		MCMoveRelative.Velocity:=AxisController.fVelocity;
		MCMoveRelative.Acceleration:=AxisController.fAcceleration;
		MCMoveRelative.Deceleration:=AxisController.fDeceleration;
		MCMoveRelative.Jerk:=0;
		MCMoveRelative.BufferMode:=MC_BufferMode.MC_Buffered;
		bDone:=MCMoveRelative.Done;
		AxisController.bBusy:=MCMoveRelative.Busy;
		IF MCMoveRelative.Error THEN
			AxisController.bError:=TRUE;
			AxisController.iErrorID:=MCMoveRelative.ErrorID;
		END_IF
		IF NOT MCMoveRelative.Busy THEN
			eCommandLatched:=eMcCommand.Idle;
		END_IF		
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	eMcCommand.GearIn:
	
		//Dependent on +ve or -ve gear ratio determines whether to link Fw to Fw and Bw to Bw or Fw to Bw and Bw to Fw
		IF AxisController.fGearRatioNum>0 THEN
			Limits.coupledFwLimit[GVL.iAxis][1].eLimitType:=eLimitCoupling.FwSw;
			Limits.coupledFwLimit[GVL.iAxis][1].iMasterAxis:=AxisController.masterAxis;
			Limits.coupledBwLimit[GVL.iAxis][1].eLimitType:=eLimitCoupling.BwSw;
			Limits.coupledBwLimit[GVL.iAxis][1].iMasterAxis:=AxisController.masterAxis;
			
		END_IF
		IF AxisController.fGearRatioNum<0 THEN
			Limits.coupledFwLimit[GVL.iAxis][1].eLimitType:=eLimitCoupling.BwSw;
			Limits.coupledFwLimit[GVL.iAxis][1].iMasterAxis:=AxisController.masterAxis;
			Limits.coupledBwLimit[GVL.iAxis][1].eLimitType:=eLimitCoupling.FwSw;
			Limits.coupledBwLimit[GVL.iAxis][1].iMasterAxis:=AxisController.masterAxis;
		END_IF
		
		MCGearIn.Execute:=AxisController.bExecute;
		MCGearIn.RatioNumerator:=AxisController.fGearRatioNum;
		MCGearIn.RatioDenominator:=AxisController.iGearRatioDen;
		AxisController.bBusy:=MCGearIn.Busy;
		IF MCGearIn.Error THEN
			AxisController.bError:=TRUE;
			AxisController.iErrorID:=MCGearIn.ErrorID;
		END_IF
		bDone:=McGearIn.InGear;
		IF NOT MCGearIn.Busy THEN
			eCommandLatched:=eMcCommand.Idle;
		END_IF
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	eMcCommand.GearInMultiMaster:		
		//Set up limits
		FOR iMasterIndex:=1 TO 4 BY 1 DO
			IF AxisController.masterAxes[iMasterIndex].ratio>0 THEN
				Limits.coupledFwLimit[GVL.iAxis][iMasterIndex+1].eLimitType:=eLimitCoupling.FwSw;				
				Limits.coupledBwLimit[GVL.iAxis][iMasterIndex+1].eLimitType:=eLimitCoupling.BwSw;				
			END_IF
			IF AxisController.masterAxes[iMasterIndex].ratio<0 THEN
				Limits.coupledFwLimit[GVL.iAxis][iMasterIndex+1].eLimitType:=eLimitCoupling.BwSw;
				Limits.coupledBwLimit[GVL.iAxis][iMasterIndex+1].eLimitType:=eLimitCoupling.FwSw;
			END_IF
			Limits.coupledFwLimit[GVL.iAxis][iMasterIndex+1].iMasterAxis:=AxisController.masterAxes[iMasterIndex].i;
			Limits.coupledBwLimit[GVL.iAxis][iMasterIndex+1].iMasterAxis:=AxisController.masterAxes[iMasterIndex].i;
		END_FOR
		

		
		//issue with this MC block (other than everything...) is that it doesn't conform to the standard and use an execute signal. The execute
		//signal in any other block determines that when it is high one of either error,done,busy must be on. That is not the case with this block
		//what happens is it triggers, doesn't register a busy and so immediately clears as done.
		
		MCGearInMultiMaster.Enable:=AxisController.bExecute;
		MCGearInMultiMaster.GearRatio1:=AxisController.masterAxes[1].ratio;
		MCGearInMultiMaster.GearRatio2:=AxisController.masterAxes[2].ratio;
		MCGearInMultiMaster.GearRatio3:=AxisController.masterAxes[3].ratio;
		MCGearInMultiMaster.GearRatio4:=AxisController.masterAxes[4].ratio;
		
		AxisController.bBusy:=MCGearInMultiMaster.Busy;
		IF MCGearInMultiMaster.Enable THEN
			AxisController.bBusy:=TRUE;	//busy does not go immediately high when enable high 
			bDone:=FALSE;
		END_IF

		bDone:=MCGearInMultiMaster.InGear;	// This does not work, the InGear seems to trigger before they are in gear, "active" flag does not work either.
		IF MCGearInMultiMaster.Error THEN
			AxisController.bError:=TRUE;
			AxisController.iErrorID:=MCGearInMultiMaster.ErrorID;
		END_IF
		IF NOT MCGearInMultiMaster.Busy THEN
			eCommandLatched:=eMcCommand.Idle;
		END_IF
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	eMcCommand.GearOut:		
		//Gearout - remove all masters from slave
		FOR iMasterIndex:=1 TO 5 BY 1 DO
				Limits.coupledFwLimit[GVL.iAxis][iMasterIndex].eLimitType:=eLimitCoupling.None;
				Limits.coupledBwLimit[GVL.iAxis][iMasterIndex].eLimitType:=eLimitCoupling.None;
		END_FOR		
	
		MCGearOut.Execute:=AxisController.bExecute;
		AxisController.bBusy:=MCGearOut.Busy;
		bDone:=MCGearOut.Done;
		IF MCGearOut.Error THEN
			AxisController.bError:=TRUE;
			AxisController.iErrorID:=MCGearOut.ErrorID;
		END_IF
		IF NOT MCGearOut.Busy THEN
			eCommandLatched:=eMcCommand.Idle;
		END_IF
	///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////			
	eMcCommand.Jog:
		MCJog.JogForward:=AxisController.bJogForward;
		MCJog.JogBackwards:=AxisController.bJogBackward;
		bDone:=MCJog.Done;
		IF MCJog.Error THEN
			AxisController.bError:=TRUE;
			AxisController.iErrorID:=MCJog.ErrorID;
		END_IF
		IF NOT MCJog.Busy THEN
			eCommandLatched:=eMcCommand.Idle;
		END_IF
	///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////	
	eMcCommand.HomeStepAbsoluteSwitch:
		//Issue: If execute not held high the function will not reverse on its own to find the abs switch when hitting a limit
		//You have to reissue the command. I want to try and keep bExecute high
		IF (NOT Limits.FwLimit[GVL.iAxis]) OR (NOT Limits.BwLimit[GVL.iAxis]) THEN
			MCStepAbsoluteSwitch.Execute:=TRUE;
		ELSE	
			MCStepAbsoluteSwitch.Execute:=AxisController.bExecute;
		END_IF
	
		MCStepAbsoluteSwitch.Direction:= AxisController.mcHomeDirection;
		MCStepAbsoluteSwitch.SwitchMode:=AxisController.mcSwitchMode;
		MCStepAbsoluteSwitch.ReferenceSignal:=AxisController.mcSignalRef;
		MCStepAbsoluteSwitch.Velocity:=AxisController.fHomeVelocity;
		MCStepAbsoluteSwitch.Acceleration:=0;
		MCStepAbsoluteSwitch.Deceleration:=0;
		MCStepAbsoluteSwitch.Jerk:=0;
		MCStepAbsoluteSwitch.TorqueLimit:=AxisController.fHomeTorque;
		MCStepAbsoluteSwitch.SetPosition:=AxisController.fHomePosition;
		MCStepAbsoluteSwitch.TimeLimit:=AxisController.tHomeTimeLimit;
		MCStepAbsoluteSwitch.DistanceLimit:=AxisController.fHomeDistanceLimit;
		MCStepAbsoluteSwitch.PositiveLimitSwitch:= NOT Limits.FwLimit[GVL.iAxis];	//Inverted logic to normal operation
		MCStepAbsoluteSwitch.NegativeLimitSwitch:= NOT Limits.BwLimit[GVL.iAxis];	//Inverted logic to normal operation
		MCStepAbsoluteSwitch.BufferMode:=AxisController.buffer;
		StOptions4.DisableDriveAccess:=TRUE;
		MCStepAbsoluteSwitch.Options:=StOptions4;
		
		bDone:=MCStepAbsoluteSwitch.Done;
		AxisController.bBusy:=MCStepAbsoluteSwitch.Busy;
		IF MCStepAbsoluteSwitch.Error THEN
			AxisController.bError:=TRUE;
			AxisController.iErrorID:=MCStepAbsoluteSwitch.ErrorID;
		END_IF
		IF NOT MCStepAbsoluteSwitch.Busy THEN
			eCommandLatched:=eMcCommand.Idle;
		END_IF
	///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////	
	eMcCommand.HomeFinish:
		MCFinishHoming.Execute:=AxisController.bExecute;
		MCFinishHoming.Distance:=AxisController.fHomeDistance;
		MCFinishHoming.Velocity:=AxisController.fHomeVelocity;
		StOptions2.DisableDriveAccess:=TRUE;
		MCFinishHoming.Options:=StOptions2;
		
		bDone:=MCFinishHoming.Done;
		AxisController.bBusy:=MCFinishHoming.Busy;
		IF MCFinishHoming.Error THEN
			AxisController.bError:=TRUE;
			AxisController.iErrorID:=MCFinishHoming.ErrorID;
		END_IF
		IF NOT MCFinishHoming.Busy THEN
			eCommandLAtched:=eMcCommand.Idle;
		END_IF
	///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////	
	eMcCommand.MoveVelocity:
		MCMoveVelocity.Execute:=AxisController.bExecute;
		MCMoveVelocity.Acceleration:=AxisController.fAcceleration;
		MCMoveVelocity.Deceleration:=AxisController.fDeceleration;
		
		IF AxisController.fVelocity>= 0 THEN
			MCMoveVelocity.Velocity:=AxisController.fVelocity;
			MCMoveVelocity.Direction:= MC_Positive_Direction;
		ELSE
			MCMoveVelocity.Velocity:=ABS(AxisController.fVelocity);
			MCMoveVelocity.Direction:= MC_Negative_Direction;
		END_IF
		
		bDone:=MCMoveVelocity.InVelocity;
		AxisController.bBusy:=MCMoveVelocity.Busy;
		IF MCMoveVelocity.Error THEN
			AxisController.bError:=TRUE;
			AxisController.iErrorID:=MCMoveVelocity.ErrorID;
		END_IF
		IF NOT MCMoveVelocity.Busy THEN
			eCommandLatched:=eMcCommand.Idle;
		END_IF
	///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////	
	eMcCommand.Stop:
		McStop.Execute:=AxisController.bExecute;
		McStop.Deceleration:=AxisController.fDeceleration;
		McStop.Deceleration:=500;
		McStop.Jerk:=0;
		
		bDone:=McStop.Done;
		AxisController.bBusy:=McStop.Busy;
		IF MCStop.Error THEN
			AxisController.bError:= TRUE;
			AxisController.iErrorID:=MCStop.ErrorId;
		END_IF
		IF	NOT MCStop.Busy THEN
			eCommandLatched:=eMcCommand.Idle;
		END_IF
		
		
		

END_CASE

////////////////////////////////////////// 
//  _____ _        _    ____ ____  		//
// |  ___| |      / \  / ___/ ___| 		//
// | |_  | |     / _ \| |  _\___ \ 		//
// |  _| | |___ / ___ | |_| |___) |		//
// |_|   |_____/_/   \_\____|____/ 		//
//                                		//
//////////////////////////////////////////
AxisController.bMoving:=AxisController.Axis.Status.Moving;

//Logic to latch on the done signal. As per the standard, unless the execute line is held high, there will be no done 
//output, so this latches that signal the one cycle it is on.
//doneLatch(SET1:=bDone,RESET:=AxisController.bBUSY OR AxisController.bERROR);
//AxisController.latchDONE:=doneLatch.Q1;
//
//errorLatch(SET1:=AxisController.bERROR, RESET:=AxisController.bBUSY OR bDone);
//AxisController.latchERROR:=errorLatch.Q1;

			
AxisController.bExecute:=FALSE;



doneLatch(SET1:=bDone,RESET:=(AxisController.bBusy OR AxisController.bError));
AxisController.bDone:=doneLatch.Q1;]]></ST>
    </Implementation>
    <LineIds Name="AxDriveFB">
      <LineId Id="4351" Count="48" />
      <LineId Id="5036" Count="16" />
      <LineId Id="5034" Count="0" />
      <LineId Id="4413" Count="1" />
      <LineId Id="5033" Count="0" />
      <LineId Id="4416" Count="0" />
      <LineId Id="4418" Count="1" />
      <LineId Id="4433" Count="0" />
      <LineId Id="4435" Count="16" />
      <LineId Id="4454" Count="71" />
      <LineId Id="4527" Count="2" />
      <LineId Id="5030" Count="0" />
      <LineId Id="4532" Count="140" />
      <LineId Id="4676" Count="1" />
      <LineId Id="4680" Count="0" />
      <LineId Id="4997" Count="0" />
      <LineId Id="4681" Count="2" />
      <LineId Id="4998" Count="2" />
      <LineId Id="4691" Count="16" />
      <LineId Id="5031" Count="1" />
      <LineId Id="5002" Count="0" />
      <LineId Id="5004" Count="0" />
      <LineId Id="5015" Count="0" />
      <LineId Id="5005" Count="0" />
      <LineId Id="5018" Count="1" />
      <LineId Id="5021" Count="0" />
      <LineId Id="5017" Count="0" />
      <LineId Id="5023" Count="1" />
      <LineId Id="5003" Count="0" />
      <LineId Id="4741" Count="0" />
      <LineId Id="4790" Count="6" />
      <LineId Id="5026" Count="2" />
      <LineId Id="5025" Count="0" />
      <LineId Id="4801" Count="16" />
      <LineId Id="4824" Count="0" />
      <LineId Id="4826" Count="0" />
      <LineId Id="4828" Count="0" />
      <LineId Id="4831" Count="0" />
      <LineId Id="4834" Count="0" />
      <LineId Id="4836" Count="144" />
      <LineId Id="9" Count="0" />
    </LineIds>
  </POU>
</TcPlcObject>